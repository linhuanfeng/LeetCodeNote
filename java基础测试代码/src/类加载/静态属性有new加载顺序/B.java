package 类加载.静态属性有new加载顺序;

/**
 * ☝第四题解析
 * 答案：C
 * 开始时JVM加载B.class，对所有的静态成员进行声明，t1 t2被初始化为默认值，为null，又因为t1 t2需要被显式初始化，
 * 所以对t1进行显式初始化，初始化代码块→构造函数（没有就是调用默认的构造函数），咦！静态代码块咋不初始化？因为
 * 在开始时已经对static部分进行了初始化，虽然只对static变量进行了初始化，但在初始化t1时也不会再执行static块了，
 * 因为JVM认为这是第二次加载类B了，所以static会在t1初始化时被忽略掉，所以直接初始化非static部分，也就是构造块
 * 部分（输出''构造块''）接着构造函数（无输出）。接着对t2进行初始化过程同t1相同（输出'构造块'），此时就对所有
 * 的static变量都完成了初始化，接着就执行static块部分（输出'静态块'），接着执行，main方法，同样也，new了对象，
 * 调用构造函数输出（'构造块'）
 * 执行的时候，并不牵扯到静态代码块，所以只有构造代码块与构造方法，之后创造对象的时候，才需要进行静态代码块的执行
 *
 * 构造代码块 -->触发类的加载，从静态属性t1,t2开始,由于JVM认为是第二次加载B,所以new B的时候不会去执行静态代码块，只是执行非静态属性代码块构造方法
 * 构造方法A
 * 构造代码块
 * 构造方法A
 * 静态代码块 -->继续最初的类加载
 * 构造代码块
 * 构造方法A
 */
public class B {
        public static B t1 = new B();
        public static B t2 = new B();
        {
            System.out.println("构造代码块");
        }
        static {
            System.out.println("静态代码块");
        }
    public B()
    {
        System.out.println("构造方法A");
    }
    public static void main(String[] args) {
        B t = new B();
    }
    }
